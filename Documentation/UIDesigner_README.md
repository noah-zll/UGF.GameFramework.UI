# UI设计器使用指南

## 概述

UI设计器（UIDesigner）是UGF.GameFramework.UI扩展包的核心工具，它提供了一种全新的UI开发流程：

1. **设计阶段**：使用UIDesigner脚本标记UI界面和组件
2. **生成阶段**：自动生成两个partial分部类
   - 组件绑定类（自动生成，不可编辑）
   - 业务逻辑类（可编辑）
3. **开发阶段**：在业务逻辑类中编写具体的UI逻辑

## 核心优势

### 1. 关注点分离
- **组件绑定类**：专注于UI组件的序列化字段定义和验证
- **业务逻辑类**：专注于UI的交互逻辑和业务处理
- 清晰的职责划分，提高代码可维护性

### 2. 直接组件引用
- 通过序列化字段直接绑定组件，无需运行时查找
- 避免了transform.Find的性能开销和路径依赖
- 在Inspector中直观地管理组件引用关系

### 3. 自动同步
- UI结构变化时，重新生成绑定类即可自动同步
- 自动生成序列化字段和公共属性访问器
- 减少因UI变更导致的代码维护工作

### 4. 代码安全
- 自动生成的绑定类不可编辑，避免意外修改
- 业务逻辑类可自由编辑，不会被覆盖
- 编译时检查，及早发现组件绑定问题
- 运行时验证组件绑定状态，提供调试信息

### 5. 开发效率
- 拖拽式组件绑定，无需手动编写查找代码
- 一键生成UI组件绑定代码和事件处理模板
- 简化的组件绑定，专注于单个组件管理
- 减少重复的样板代码编写

### 6. 可维护性
- 统一的代码结构和命名规范
- 清晰的文件组织和依赖关系
- 便于团队协作和代码审查
- 直观的组件引用管理

这种设计模式的优势：
- **代码分离**：组件绑定代码与业务逻辑代码完全分离
- **自动化**：组件绑定代码完全自动生成，减少手动编写错误
- **可维护性**：业务逻辑代码独立，便于维护和版本控制
- **团队协作**：设计师可以专注于UI设计，程序员专注于逻辑实现

## 使用流程

### 第一步：添加UIDesigner脚本

1. 在UI预制体的根节点上添加`UIDesigner`组件
2. 配置基本信息：
   - **UI界面名称**：如 `MainMenu`、`SettingsPanel` 等
   - **命名空间**：如 `Game.UI`、`Project.UI` 等
   - **自动生成代码**：是否在保存时自动生成代码

### 第二步：配置组件绑定

#### 直接绑定组件
1. 在UIDesigner的Inspector面板中
2. 直接将UI组件拖拽到对应的组件字段中
3. 系统会自动设置变量名称、组件类型和序列化字段名
4. 支持单个组件的绑定

#### 手动添加组件
1. 点击"添加组件绑定"按钮
2. 设置组件信息：
   - **变量名称**：在代码中使用的变量名
   - **绑定组件**：拖拽要绑定的UI组件
   - **组件类型**：自动识别或手动设置

   - **描述**：组件的用途说明

#### 自动扫描组件
1. 点击"自动扫描组件"按钮
2. 系统会自动扫描所有子组件并添加到绑定列表
3. 自动生成合适的变量名称
4. 可以手动调整扫描结果

### 第三步：生成代码

点击"生成代码"按钮，系统会在指定目录生成两个文件：

#### 1. 组件绑定类（不可编辑）
文件名：`{UI界面名称}Binding.Generated.cs`

```csharp
// <auto-generated>
// 此代码由UIDesigner自动生成，请勿手动修改
// </auto-generated>

using UnityEngine;
using UnityGameFramework.Runtime;

namespace Game.UI
{
    public partial class MainMenu : UIFormBase
    {
        // 自动生成的序列化字段
        [SerializeField] private Button _startButton;
        [SerializeField] private Button _settingsButton;
        [SerializeField] private Button _exitButton;
        
        // 公共属性访问器
        /// <summary>
        /// 开始游戏按钮
        /// </summary>
        public Button StartButton => _startButton;
        
        /// <summary>
        /// 设置按钮
        /// </summary>
        public Button SettingsButton => _settingsButton;
        
        /// <summary>
        /// 退出按钮
        /// </summary>
        public Button ExitButton => _exitButton;
        
        /// <summary>
        /// 绑定UI组件（自动生成）
        /// </summary>
        private void BindComponents()
        {
            // 组件已通过序列化字段直接绑定，无需运行时查找
            // 验证单个组件: StartButton
            if (_startButton == null)
                Debug.LogWarning($"组件 StartButton 未正确绑定");
            // 验证单个组件: SettingsButton
            if (_settingsButton == null)
                Debug.LogWarning($"组件 SettingsButton 未正确绑定");
            // 验证单个组件: ExitButton
            if (_exitButton == null)
                Debug.LogWarning($"组件 ExitButton 未正确绑定");
        }
        
        /// <summary>
        /// 界面初始化（自动调用组件绑定）
        /// </summary>
        protected override void OnInit(object userData)
        {
            base.OnInit(userData);
            BindComponents();
            OnInitCustom(userData);
        }
        
        /// <summary>
        /// 自定义初始化逻辑（在业务逻辑类中实现）
        /// </summary>
        partial void OnInitCustom(object userData);
    }
}
```

#### 2. 业务逻辑类（可编辑）
文件名：`{UI界面名称}.cs`

```csharp
using UnityEngine;
using UnityGameFramework.Runtime;

namespace Game.UI
{
    /// <summary>
    /// MainMenu 业务逻辑类
    /// </summary>
    public partial class MainMenu
    {
        /// <summary>
        /// 自定义初始化逻辑
        /// </summary>
        partial void OnInitCustom(object userData)
        {
            // 绑定按钮事件
            startButton.onClick.AddListener(OnStartButtonClick);
            settingsButton.onClick.AddListener(OnSettingsButtonClick);
            exitButton.onClick.AddListener(OnExitButtonClick);
        }
        
        /// <summary>
        /// 界面打开时调用
        /// </summary>
        protected override void OnOpen(object userData)
        {
            base.OnOpen(userData);
            // 界面打开时的初始化逻辑
            RefreshUI();
        }
        
        /// <summary>
        /// 界面关闭时调用
        /// </summary>
        protected override void OnClose(bool isShutdown, object userData)
        {
            // 界面关闭时的清理逻辑
            base.OnClose(isShutdown, userData);
        }
        
        /// <summary>
        /// 刷新UI显示
        /// </summary>
        private void RefreshUI()
        {
            // 更新UI显示逻辑
        }
        
        #region 按钮事件处理
        
        private void OnStartButtonClick()
        {
            // 开始游戏
            GameEntry.GetComponent<UIComponent>().OpenUIForm("GameplayUI");
            Close();
        }
        
        private void OnSettingsButtonClick()
        {
            // 打开设置界面
            GameEntry.GetComponent<UIComponent>().OpenUIForm("SettingsUI");
        }
        
        private void OnExitButtonClick()
        {
            // 退出游戏
            Application.Quit();
        }
        
        #endregion
    }
}
```

### 第四步：使用生成的代码

1. **组件绑定类**：由系统自动维护，包含所有UI组件的引用和绑定逻辑
2. **业务逻辑类**：开发者在此编写具体的UI逻辑，如事件处理、数据绑定等
3. **partial关键字**：两个类通过partial关键字合并为一个完整的类

## 高级功能



## 扩展示例

### 复杂UI组件绑定

```csharp
// MainMenuUI.Generated.cs (自动生成，不可编辑)
public partial class MainMenuUI : UIFormBase
{
    // 序列化字段 - 按钮组件
    [SerializeField] private Button _startButton;
    [SerializeField] private Button _settingsButton;
    [SerializeField] private Button _exitButton;
    
    // 序列化字段 - 文本组件
    [SerializeField] private Text _titleText;
    [SerializeField] private Text _versionText;
    
    // 序列化字段 - 图片组件
    [SerializeField] private Image _backgroundImage;
    [SerializeField] private Image _logoImage;
    
    // 序列化字段 - 滑动条组件
    [SerializeField] private Slider _volumeSlider;
    
    // 序列化字段 - 输入框组件
    [SerializeField] private InputField _playerNameInput;
    
    // 序列化字段 - 下拉框组件
    [SerializeField] private Dropdown _languageDropdown;
    

    
    // 公共属性访问器
    public Button StartButton => _startButton;
    public Button SettingsButton => _settingsButton;
    public Button ExitButton => _exitButton;
    public Text TitleText => _titleText;
    public Text VersionText => _versionText;
    public Image BackgroundImage => _backgroundImage;
    public Image LogoImage => _logoImage;
    public Slider VolumeSlider => _volumeSlider;
    public InputField PlayerNameInput => _playerNameInput;
    public Dropdown LanguageDropdown => _languageDropdown;

    
    private void BindComponents()
    {
        // 组件已通过序列化字段直接绑定，无需运行时查找
        // 验证单个组件绑定
        if (_startButton == null)
            Debug.LogWarning($"组件 StartButton 未正确绑定");
        if (_settingsButton == null)
            Debug.LogWarning($"组件 SettingsButton 未正确绑定");
        if (_exitButton == null)
            Debug.LogWarning($"组件 ExitButton 未正确绑定");
        if (_titleText == null)
            Debug.LogWarning($"组件 TitleText 未正确绑定");
        if (_versionText == null)
            Debug.LogWarning($"组件 VersionText 未正确绑定");
        if (_backgroundImage == null)
            Debug.LogWarning($"组件 BackgroundImage 未正确绑定");
        if (_logoImage == null)
            Debug.LogWarning($"组件 LogoImage 未正确绑定");
        if (_volumeSlider == null)
            Debug.LogWarning($"组件 VolumeSlider 未正确绑定");
        if (_playerNameInput == null)
            Debug.LogWarning($"组件 PlayerNameInput 未正确绑定");
        if (_languageDropdown == null)
            Debug.LogWarning($"组件 LanguageDropdown 未正确绑定");
        

    }
    
    protected override void OnInit(object userData)
    {
        base.OnInit(userData);
        BindComponents();
        OnInitCustom(userData);
    }
    
    partial void OnInitCustom(object userData);
}
```

```csharp
// MainMenuUI.cs (业务逻辑类，可编辑)
public partial class MainMenuUI
{
    partial void OnInitCustom(object userData)
    {
        // 自定义初始化逻辑
        InitializeEvents();
        SetupUI();
    }
    
    private void InitializeEvents()
    {
        // 绑定单个按钮事件
        StartButton.onClick.AddListener(OnStartButtonClick);
        SettingsButton.onClick.AddListener(OnSettingsButtonClick);
        ExitButton.onClick.AddListener(OnExitButtonClick);
        
        // 绑定滑动条事件
        VolumeSlider.onValueChanged.AddListener(OnVolumeChanged);
        
        // 绑定输入框事件
        PlayerNameInput.onEndEdit.AddListener(OnPlayerNameChanged);
        
        // 绑定下拉框事件
        LanguageDropdown.onValueChanged.AddListener(OnLanguageChanged);
        
        // 绑定按钮数组事件
        for (int i = 0; i < MenuButtonArray.Length; i++)
        {
            int index = i; // 避免闭包问题
            MenuButtonArray[i].onClick.AddListener(() => OnMenuButtonArrayClick(index));
        }
        
        // 绑定文本数组（如果需要交互）
        for (int i = 0; i < MenuTextArray.Length; i++)
        {
            // 文本组件通常不需要事件绑定，这里仅作示例
            // 可以添加鼠标悬停效果等
        }
    }
    
    private void SetupUI()
    {
        // 设置UI初始状态
        TitleText.text = "游戏主菜单";
        VersionText.text = $"版本 {Application.version}";
        VolumeSlider.value = PlayerPrefs.GetFloat("Volume", 1.0f);
        PlayerNameInput.text = PlayerPrefs.GetString("PlayerName", "玩家");
        
        // 设置菜单文本数组内容
        string[] menuLabels = { "新游戏", "继续游戏", "多人游戏", "成就" };
        for (int i = 0; i < MenuTextArray.Length && i < menuLabels.Length; i++)
        {
            MenuTextArray[i].text = menuLabels[i];
        }
    }
    
    // 单个按钮事件处理方法
    private void OnStartButtonClick()
    {
        Debug.Log("开始游戏");
        // TODO: 实现开始游戏逻辑
    }
    
    private void OnSettingsButtonClick()
    {
        Debug.Log("打开设置");
        // TODO: 实现设置界面逻辑
    }
    
    private void OnExitButtonClick()
    {
        Debug.Log("退出游戏");
        // TODO: 实现退出游戏逻辑
    }
    
    // 其他组件事件处理方法
    private void OnVolumeChanged(float value)
    {
        PlayerPrefs.SetFloat("Volume", value);
        // TODO: 实现音量调节逻辑
    }
    
    private void OnPlayerNameChanged(string playerName)
    {
        PlayerPrefs.SetString("PlayerName", playerName);
        // TODO: 实现玩家名称保存逻辑
    }
    
    private void OnLanguageChanged(int languageIndex)
    {
        // TODO: 实现语言切换逻辑
    }
    
    // 数组组件事件处理方法
    private void OnMenuButtonArrayClick(int index)
    {
        Debug.Log($"点击了菜单按钮数组 [{index}]: {MenuTextArray[index].text}");
        
        switch (index)
        {
            case 0: // 新游戏
                // TODO: 实现新游戏逻辑
                break;
            case 1: // 继续游戏
                // TODO: 实现继续游戏逻辑
                break;
            case 2: // 多人游戏
                // TODO: 实现多人游戏逻辑
                break;
            case 3: // 成就
                // TODO: 实现成就界面逻辑
                break;
        }
    }
    
    // 生命周期方法
    protected override void OnOpen(object userData)
    {
        base.OnOpen(userData);
        // TODO: 实现界面打开逻辑
    }
    
    protected override void OnClose(bool isShutdown, object userData)
    {
        base.OnClose(isShutdown, userData);
        // TODO: 实现界面关闭逻辑
    }
}
```

### 自定义组件类型

支持绑定自定义组件类型：

```csharp
// 自定义组件
public class CustomSlider : MonoBehaviour { }

// 在UIDesigner中设置componentType = "CustomSlider"
public CustomSlider customSlider { get; private set; }
```

### 批量代码生成

```csharp
// 在编辑器中批量生成所有UIDesigner的代码
[MenuItem("Tools/UI/Generate All UI Code")]
public static void GenerateAllUICode()
{
    UICodeGenerator.GenerateAllCode();
}
```

## 最佳实践

### 1. 命名规范

- **UI界面名称**：使用PascalCase，如 `MainMenu`、`InventoryPanel`
- **变量名称**：使用camelCase，如 `startButton`、`healthBar`
- **命名空间**：使用项目统一的命名空间，如 `Game.UI`

### 2. 组件组织

- 将相关的UI组件放在同一个父节点下
- 使用有意义的GameObject名称
- 避免过深的层级结构

### 3. 代码管理

- **不要修改**生成的组件绑定类（.Generated.cs文件）
- 将业务逻辑类加入版本控制
- 定期重新生成代码以保持同步

### 4. 团队协作

- UI设计师负责UIDesigner的配置
- 程序员负责业务逻辑类的实现
- 通过代码生成保持两者的同步

## 注意事项

1. **文件覆盖**：组件绑定类会被完全覆盖，不要在其中添加自定义代码
2. **依赖关系**：确保UIFormBase和相关依赖已正确导入
3. **编译顺序**：先生成组件绑定类，再编写业务逻辑类
4. **版本控制**：建议将.Generated.cs文件排除在版本控制之外

## 故障排除

### 常见问题

1. **编译错误**：检查命名空间和类名是否正确
2. **组件为空**：检查组件绑定路径是否正确
3. **重复定义**：确保没有手动创建同名的类
4. **找不到组件**：检查组件是否在正确的层级位置

### 调试技巧

1. 使用"验证设置"按钮检查配置
2. 查看生成的代码是否符合预期
3. 在OnInitCustom方法中添加调试日志
4. 使用Unity的Inspector查看组件绑定状态

## 总结

UIDesigner提供了一种现代化的UI开发流程，通过代码生成和分离关注点的方式，大大提高了UI开发的效率和代码质量。正确使用这个工具可以让团队更好地协作，减少重复工作，提高项目的可维护性。